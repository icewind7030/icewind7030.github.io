
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  
    <title>如何使用Storybook和Gitlab CI/CD搭建自动化的前端公共组件库 | Icewind Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Icewind">
    
    <meta name="description" content="本文主要介绍的是采用Storybook和Gitlab CI/CD搭建和部署LOFTER官网新的公共组件库的一些指南和实践经验。">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="Icewind Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/l_favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/l_retina.png">
    <link rel="apple-touch-icon-precomposed" href="/img/l_retina.png">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/l_rec.png" alt="Icewind Blog" title="Icewind Blog"></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Icewind Blog">Icewind Blog</a></h1>
				<h2 class="blog-motto">Share makes it a better world.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search">
					</form>
					
					</li>
				</ul>
			</ul></nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope="" itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/10/14/storybook/" title="如何使用Storybook和Gitlab CI/CD搭建自动化的前端公共组件库" itemprop="url">如何使用Storybook和Gitlab CI/CD搭建自动化的前端公共组件库</a>
  </h1>
  <p class="article-author">By
      <a href="http://icewind-blog.com/about" title="Icewind" target="_blank">Icewind</a>
  </p><p class="article-time">
    <time datetime="2020-10-14T07:28:52.000Z" itemprop="datePublished">发表于2020-10-14</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#选型"><span class="toc-number">1.</span> <span class="toc-text">选型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#需求"><span class="toc-number">1.1.</span> <span class="toc-text">需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对比"><span class="toc-number">1.2.</span> <span class="toc-text">对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bisheng"><span class="toc-number">1.2.1.</span> <span class="toc-text">Bisheng</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#优点"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缺点"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Storybook"><span class="toc-number">1.2.2.</span> <span class="toc-text">Storybook</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#优点-1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缺点-1"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Storybook-1"><span class="toc-number">2.</span> <span class="toc-text">Storybook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍"><span class="toc-number">2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用方式"><span class="toc-number">2.2.</span> <span class="toc-text">使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理简介"><span class="toc-number">2.3.</span> <span class="toc-text">原理简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用要点"><span class="toc-number">2.4.</span> <span class="toc-text">使用要点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件的设计原则"><span class="toc-number">3.</span> <span class="toc-text">组件的设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件文档规范"><span class="toc-number">4.</span> <span class="toc-text">组件文档规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件库的CI-CD自动化持续集成"><span class="toc-number">5.</span> <span class="toc-text">组件库的CI/CD自动化持续集成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Gitlab-CI-CD自动构建"><span class="toc-number">5.1.</span> <span class="toc-text">使用Gitlab CI/CD自动构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配合Gitlab-Runner的Docker实现持续集成"><span class="toc-number">5.2.</span> <span class="toc-text">配合Gitlab Runner的Docker实现持续集成</span></a></li></ol></li></ol>
		
		</div>
		
		<p>本文主要介绍的是采用<code>Storybook</code>和<code>Gitlab CI/CD</code>搭建和部署LOFTER官网新的公共组件库的一些指南和实践经验。</p>
<a id="more"></a>
<p>LOFTER的官网是一个覆盖PC和H5的规模比较大的网站，由于其存在时间较长，技术栈较为陈旧，公共组件也比较混乱。所以20年针对LOFTER官网的一些新的更新和维护需求，我们都优先采用相对较新的技术栈（也就是<code>React</code>）来进行开发。而对于一个较为大型的网站来说，使用了新的技术栈，就势必会产生很多的新的组件：UI的、非UI的等等。这些组件如果不能得到妥善的组织和管理，即时使用的是<code>React</code>来开发组件，也会随着规模的扩大而变得难以维护。所以，找到一套能够统一查看和管理LOFTER官网组件的方案势在必行。</p>
<h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>针对公共组件库，光靠代码的管理可能还不够，一旦组件的规模到了一定程度后，可视化的组件库文档平台将会非常必要。我们的搭建和选择组件库的主要诉求就是：</p>
<ul>
<li>平台可以列出所有可选的组件，方便开发选择和查看</li>
<li>每一组件都有足够详细和规范的文档，方便开发者使用</li>
<li>组件的文档撰写简单、内容充足，不需要组件的开发者花费过大的精力</li>
<li>平台的搭建成本要尽量低，优先不自己造轮子</li>
<li>平台的扩展性和维护性要足够好，也就是其社区要足够活跃</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>经过了一些调研，主要选择集中在了<code>Bisheng</code>和<code>Storybook</code>之间。</p>
<h4 id="Bisheng"><a href="#Bisheng" class="headerlink" title="Bisheng"></a><code>Bisheng</code></h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li><code>Ant Design</code>使用，UI美观大方，稳定性比较有保障</li>
<li>完整的<code>Markdown</code>语法支持</li>
<li>功能强大且灵活，自定义程度高<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5></li>
<li>缺少详细的文档和示例</li>
<li>功能偏基础，自定义程度过高，搭建规范的组件库还需要进一步的开发</li>
</ul>
<h4 id="Storybook"><a href="#Storybook" class="headerlink" title="Storybook"></a><code>Storybook</code></h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>社区活跃，生态繁荣，技术栈支持广泛</li>
<li>功能强大，集成度高，支持<code>JS</code>和<code>MDX</code>两种写法</li>
<li>带有脚手架，无需过多配置即可安装成功</li>
<li>自动读取组件参数，并且生成可交互式的组件文档</li>
</ul>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>UI不够美观</li>
</ul>
<p>鉴于我们的主要目的是快捷直观的搭建可视化的组件库平台，所以最终还是选择了<code>Storybook</code></p>
<h2 id="Storybook-1"><a href="#Storybook-1" class="headerlink" title="Storybook"></a>Storybook</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>Storybook is a development environment for UI components. It allows you to browse a component library, view the different states of each component, and interactively develop and test components.<br>Storybook是UI组件的展示平台。它使得你可以查阅组件库中的所有组件的文档，还可以查看各组件在不同参数下的表现，甚至可以互动式的开发和测试你的组件。</p>
</blockquote>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol>
<li>在一个<strong>不是空白的项目</strong>中运行命令<code>npx sb init</code>，会自动执行<code>Storybook</code>的初始化过程。</li>
<li>项目不是空白指的是项目需要已经配置好了某个开发框架的所需配置了，比如使用<code>Create React App</code>或者<code>Vue CLI</code>等工具或者自行搭建的工程项目。</li>
<li>初始化命令使用了<code>Storybook CLI</code>工具来自动执行以下逻辑：<ul>
<li>依赖安装</li>
<li>脚本注入</li>
<li>配置注入</li>
<li>示例注入</li>
</ul>
</li>
<li>初始化成功后，执行命令<code>npm run storybook</code>即可打开具有热更新的组件文档预览平台</li>
</ol>
<h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><ul>
<li><code>Storybook</code>有几个比较核心的模块<ul>
<li><code>@storybook/core</code>负责平台的主体框架和各部分的渲染</li>
<li><code>@storybook/client-api</code>负责组件的解析和预览</li>
<li><code>@storybook/api</code>负责组件的管理和交互</li>
</ul>
</li>
<li>组件的文档以<code>Story</code>为单位，<code>Storybook</code>会通过<code>storiesOf</code>中的<code>add</code>方法解析出每个<code>Story</code>的目录、名称、标识、配置、参数以及事件,其中有2个比较重要的概念：配置和参数:<ul>
<li>配置<code>parameters</code>是该组件文档的一些静态的配置内容，比如组件的自定义描述，组件的文档格式等等，合并了系统内置和用户自定义配置的两种。<code>parameters</code>在组件文档平台完成构建后基本是不变的，除非是在调试平台期间，修改了<code>Story</code>引发了平台本身的热更新。</li>
<li>参数<code>args</code>是组件的入参，包括了<code>Storybook</code>读取了组件的参数后自动识别出来的部分，以及<code>Story</code>的撰写者手动修改的部分，<code>args</code>在组件平台完成构建和展示后，可以在平台上进行交互式的修改，预览的组件会同步<code>args</code>的变化.</li>
</ul>
</li>
<li><p><code>Storybook</code>平台的组件渲染有两种模式：<code>iframe</code>和<code>inline</code>模式，组件的展示有2个tab，<code>Canvas</code>和<code>Docs</code></p>
<ul>
<li>在<code>Canvas</code>tab下组件的渲染方式只能为<code>iframe</code>模式，这样不仅能实现完全的样式和作用域隔离，还能更好的支持一些<code>rem</code>布局的组件展示效果。<code>iframe</code>的渲染模块和<code>Storybook</code>平台管理模块通过<code>PostMessage</code>的方式进行通信。<br><img src="https://easyreadfs.nosdn.127.net/1602827260124/canvas.png" alt="canvas"></li>
<li>在<code>Docs</code>tab下，组件的渲染这两种方式都支持：<code>React</code>和 <code>Vue</code>框架编写的组件，默认使用<code>inline</code>模式渲染，也就是调用解析过的组件的<code>render</code>方法渲染在当前页面。而其他框架编写的组件，默认是使用<code>iframe</code>模式渲染的，该模式虽然可以提供完整的隔离环境，但是渲染在组件文档中，iframe的高度需要手动指定，并行某些交互式的文档工具可能会失效。</li>
<li>值得注意的是，在<code>Docs</code>tab下，<code>Storybook</code>对于<code>Vue</code>框架编写的组件，是通过使用<a href="https://github.com/egoist/vue-to-react" target="_blank" rel="noopener">@egoist/vue-to-react</a>工具将其转化为<code>React</code>组件再渲染在当前页的，所以，如果使用其他框架开发的组件，比如<code>Angular</code>、<code>Regular</code>等，想要实现<code>Docs</code>tab下的<code>inline</code>模式渲染，也需要参照这种实现方案提供一个<code>prepareForInline</code>转换函数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// .storybook/preview.js</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line">  <span class="keyword">import</span> toReact <span class="keyword">from</span> <span class="string">'@egoist/vue-to-react'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> parameters = &#123;</span><br><span class="line">    docs: &#123;</span><br><span class="line">      prepareForInline: <span class="function">(<span class="params">storyFn, &#123; args &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> Story = toReact(storyFn());</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Story</span> &#123;<span class="attr">...args</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">      &#125;,</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://easyreadfs.nosdn.127.net/1602827321886/docs.png" alt="docs"></p>
</li>
<li><code>npm run storybook</code>所做的工作就是将<code>Storybook</code>的默认配置和用户自定义配置结合生成一份<code>webpackConfig</code>，同时启动了一个<code>express</code>服务器，加载了<code>webpackDevMiddleware</code>和<code>webpackHotMiddleware</code>这2个中间件，实现了组件文档平台的热更新。</li>
</ul>
<h3 id="使用要点"><a href="#使用要点" class="headerlink" title="使用要点"></a>使用要点</h3><ol>
<li><p>组件文件夹下添加<code>*.stories.(js|jsx|ts|tsx)</code>，会被自动扫描到并编译加入storybook中（扫描规则可以在<code>.storybook/main.js</code>中的<code>stories</code>字段配置）,这种组件文件的形式叫做<code>CSF</code>（Component Story Format）。</p>
</li>
<li><p>每个<code>stories</code>文件<code>Default Export</code>默认导出的是该组件的<code>Meta</code>信息：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  title: <span class="string">'Common/Button'</span>, <span class="comment">// 平台侧边栏目录，需全局唯一，Common为导航模块，Button为一级菜单</span></span><br><span class="line">  component: Button, <span class="comment">// 本story的主组件，最好有，主要用于Docs tab下的参数列表的自动识别及展示。如果不指定，则之后第一个导出的组件会作为主组件，参数识别可能会不全。</span></span><br><span class="line">&#125; <span class="keyword">as</span> Meta;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p><code>Storybook</code>对于自动生成的组件目录的目录名是有一套大小写的显示转换规则的：</p>
<p><img src="https://easyreadfs.nosdn.127.net/1602836152460/caps.png" alt="caps"></p>
</li>
<li><p><code>Meta</code>的<code>Title</code>中的一级二级菜单在展示时都会把首字母等变成大写，但是实际上<code>Common</code>和<code>common</code>是会被渲染成2条不同的菜单的，所以需要注意大小写的问题，建议首字母都保持大写。</p>
<blockquote>
<p> <code>title: &#39;common/Button&#39;</code>和<code>title: &#39;Common/Button&#39;</code>会被渲染到不同的目录，但是显示的时候都是大写。</p>
</blockquote>
</li>
<li><p>每个<code>stories</code>文件中的<code>Named Export</code>具名导出都叫做一个<code>story</code>（必须有），对应到<code>Default Export</code>创建的一级菜单下的二级菜单，菜单名的大小写也会被转换。</p>
</li>
<li><p>第一个具名导出的组件叫做<code>Primary</code>，它会在<code>Canvas</code>tab下展示并配有工具栏，并且在<code>Dos</code>tab的标题模块下方展示预览。其他具名导出的组件不在<code>Canvas</code>tab提供展示，只在<code>Docs</code>tab的stories模块下：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个根据入参返回组件的模板函数</span></span><br><span class="line"><span class="keyword">const</span> Template: Story&lt;ButtonConfig&gt; = <span class="function"><span class="params">args</span> =&gt;</span> &lt;Button &#123;...args&#125; /&gt;;</span><br><span class="line"><span class="comment">// 创建一个Template函数的拷贝，并且导出为story</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> large = Template.bind(&#123;&#125;);</span><br><span class="line"><span class="comment">// 指定该story的参数</span></span><br><span class="line">large.args = &#123;</span><br><span class="line">  children: <span class="string">'大号'</span>,</span><br><span class="line">  size: <span class="string">'large'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果想要自定义story的菜单名，比如设置为Javascript的一些保留字，可以使用storyName</span></span><br><span class="line">large.storyName = <span class="string">'自定义的菜单名'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以设置每个<code>story</code>的<code>StoryName</code>属性，对应设置的就是该<code>story</code>在导航中的菜单名，否则默认展示该<code>story</code>的变量名。</p>
</li>
<li><p>如果一个组件不同参数对应的不同情况比较多，可以先声明组件的<strong>函数模板</strong>，然后复用模板，最后<code>export</code>不同的参数的<code>story</code>。而如果一个组件的使用场景比较单一，可以直接<code>export</code>组件调用,不需要创建模板函数这些操作。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> normal = <span class="function"><span class="params">()</span> =&gt;</span> &lt;Button&gt;直接导出&lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Storybook</code>会自动识别组件的参数类型，我们还可以手动设置某些参数的类型<code>argTypes</code>，甚至可以设置为<code>Storybook</code>内置的一些<a href="https://storybook.js.org/docs/react/api/argtypes" target="_blank" rel="noopener">高级类型</a>：比如颜色、单选、多选、日期、数值选择等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  title: <span class="string">'Common/Button'</span>,</span><br><span class="line">  component: Button,</span><br><span class="line">  argTypes: &#123;</span><br><span class="line">    test: &#123;</span><br><span class="line">      description: <span class="string">'this is a test arguments'</span>, <span class="comment">// 参数的描述</span></span><br><span class="line">      defaultValue: <span class="string">'#f00'</span>, <span class="comment">// 参数的默认值</span></span><br><span class="line">      type: &#123; <span class="attr">name</span>: <span class="string">'color'</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;, <span class="comment">// 参数的类型以及是否必须</span></span><br><span class="line">      table: &#123; <span class="comment">// 参数表格中的展示配置</span></span><br><span class="line">        type: &#123;  <span class="comment">// 参数描述中的附加类型信息</span></span><br><span class="line">          summary: <span class="string">'something short'</span>,</span><br><span class="line">          detail: <span class="string">'something really really long'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        defaultValue: &#123; <span class="attr">summary</span>: <span class="string">'#f00'</span> &#125;, <span class="comment">// 参数表格中的默认值</span></span><br><span class="line">      &#125;,</span><br><span class="line">      control: &#123; <span class="comment">// 参数表格中的可交互式输入类型</span></span><br><span class="line">        type: <span class="string">'color'</span>, <span class="comment">// 颜色选择控制器</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125; <span class="keyword">as</span> Meta;</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="https://easyreadfs.nosdn.127.net/1602840715307/argtype.png" alt="argTypes"></p>
</li>
<li><p><code>Storybook</code>提供叫做<code>addons</code>的可扩展功能，比如内置了<code>addons/actions</code>，可以自动展示组件回调函数的调用，默认是展示以<code>on</code>开头的函数类型参数的调用（可配置，在<code>.storybook/preview.js</code>中）。</p>
</li>
<li><p>组件可以设置<code>decorators</code>属性，该属性用于某些组件的使用可能必须要有一定的父级元素或者环境的情况，简单来说就是可以通过<code>decorators</code>给组件包一层父组件。</p>
</li>
<li><p><code>story</code>本身也可以被其他<code>story</code> <code>import</code>，达到复用的目的。通常情况下，一个<code>stories</code>文件中的<code>export</code>出来的东西都会被识别成一个<code>story</code>，如果这个部分只是一个想作为被其他组件引用的元素，不想展示成<code>story</code>，可以在<code>Default Export</code>中配置<code>includeStories</code>和<code>excludeStories</code>。</p>
</li>
<li><p><code>story</code>有一个比较核心的配置项<code>parameters</code>，如果设置<code>parameters</code>为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameters: &#123; <span class="attr">docs</span>: &#123; <span class="attr">page</span>: <span class="literal">null</span> &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>此时可以清空该组件的<code>docs</code>tab下的显示内容。</p>
</li>
<li><p>如果要强制某些组件在<code>Docs</code>tab下使用<code>iframe</code>模式渲染，可以设置<code>parameters</code>伟</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameters: &#123; <span class="attr">docs</span>: &#123; <span class="attr">inlineStories</span>: <span class="literal">false</span> &#125; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们可以手动控制组件在<code>Docs</code>tab下的文档结构，一个标准的组件自动生成的文档主要包含了以下这些部分：</p>
<ul>
<li><code>&lt;Title /&gt;</code> 组件标题，通常就是<code>Component</code>对应值的变量名</li>
<li><p><code>&lt;Description /&gt;</code> 组件的描述，需要自行设定，他的值还支持<code>Markdown</code>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parameters: &#123; </span><br><span class="line">  docs: &#123; </span><br><span class="line">    description: &#123;</span><br><span class="line">      component: &apos;LOFTER官网**按钮组件**&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;Primary /&gt;</code> 首要<code>story</code>，会有带工具栏的预览展示</p>
</li>
<li><code>&lt;ArgsTable /&gt;</code> 参数表格</li>
<li><code>&lt;Stories /&gt;</code> 其他非首要<code>story</code>，展示模块不带工具栏</li>
</ul>
</li>
</ol>
<pre><code>我们可以通过如下方式，手动组织组件的文档，并且任意插入其他外部组件或者内容：
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Title,</span><br><span class="line">  Description,</span><br><span class="line">  Primary,</span><br><span class="line">  ArgsTable,</span><br><span class="line">  Stories,</span><br><span class="line">  PRIMARY_STORY,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@storybook/addon-docs/blocks'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  title: <span class="string">'Common/Button'</span>,</span><br><span class="line">  component: Button,</span><br><span class="line">  parameters: &#123;</span><br><span class="line">    docs: &#123;</span><br><span class="line">      page: <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">          &lt;MyCustomComponent /&gt; <span class="comment">// 任意其他组件</span></span><br><span class="line">          &lt;Title /&gt;</span><br><span class="line">          &lt;Description /&gt;</span><br><span class="line">          &lt;Primary /&gt;</span><br><span class="line">          &lt;ArgsTable story=&#123;PRIMARY_STORY&#125; /&gt; <span class="comment">// argsTable需要显式指定story</span></span><br><span class="line">          &lt;Stories /&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">      ),</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125; as Meta;</span></span><br></pre></td></tr></table></figure>
</code></pre><ol start="16">
<li><p>如果需要自定义程度更高或者文档格式更为丰富的组件文档，可以使用<code>MDX</code>文件，它是<code>Markdown</code>和<code>JSX</code>的结合的一种文件格式，具体可以参考<a href="https://mdxjs.com/" target="_blank" rel="noopener">MDX</a>的讲解,还可以参考<code>Storybook</code>初始化后附带的示例中的<code>MDX</code>文件。以下为<code>MDX</code>的示例:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--- index.stories.mdx --&gt;</span></span></span><br><span class="line"></span><br><span class="line">import &#123; Meta, Story, Canvas, ArgsTable, PRIMARY_STORY &#125; from '@storybook/addon-docs/blocks';</span><br><span class="line">import &#123; Button &#125; from './index';</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Meta</span> <span class="attr">title</span>=<span class="string">"MDX/Button"</span> <span class="attr">component</span>=<span class="string">&#123;Button&#125;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">## 前言</span></span><br><span class="line">With <span class="code">`MDX`</span> we can define a story for <span class="code">`Button`</span> right in the middle of our</span><br><span class="line">Markdown documentation.</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 使用`MDX`我们可以在Markdown文档中插入`Button`组件的story。</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 组件展示</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 组件可以写在一个画板里，也可以分成多个</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--- This is your Story template function, shown here in React --&gt;</span></span></span><br><span class="line"></span><br><span class="line">export const Template = (args) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">Button</span> &#123;<span class="attr">...args</span>&#125; /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">### 正常大小</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Canvas</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Story</span> <span class="attr">name</span>=<span class="string">"Normal"</span> <span class="attr">args</span>=<span class="string">&#123;&#123;</span> </span></span></span><br><span class="line"><span class="xml">    children: '普通大小',</span></span><br><span class="line"><span class="xml">    &#125;&#125;&gt;</span></span><br><span class="line"><span class="code">    &#123;Template.bind(&#123;&#125;)&#125;</span></span><br><span class="line">   <span class="xml"><span class="tag">&lt;/<span class="name">Story</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Canvas</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">### 大号</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Canvas</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Story</span> <span class="attr">id</span>=<span class="string">"common-button--large"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">Story</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Canvas</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">### 中号</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Canvas</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Story</span> <span class="attr">id</span>=<span class="string">"common-button--middle"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">Story</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Canvas</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">## 组件参数</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ArgsTable</span> <span class="attr">story</span>=<span class="string">&#123;PRIMARY_STORY&#125;/</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>MDX</code>中的<code>meta</code>组件和<code>CSF</code>中的默认导出具有同样的作用，<code>MDX</code>中使用的每个<code>story</code>组件必须指定该文件内唯一的<code>name</code>，如果不写任何<code>story</code>组件，只写<code>meta</code>组件，那么就是一份纯文本类型的文档。</p>
</li>
<li><p><code>MDX</code>中可以直接引用<code>stories</code>文件中定义过的<code>story</code>，需要找到该<code>story</code>的唯一ID即可（可以从URL中复制），比如上面代码中的<code>&lt;Story id=&quot;common-button--large&quot;&gt;&lt;/Story&gt;</code>。</p>
</li>
<li><p><code>MDX</code>中还可以插入<code>style</code>以及<code>html</code>，具体可以参考<code>stories</code>示例文件夹下的<code>introduction.stories.mdx</code>文件。</p>
</li>
<li><p><code>Storybook</code>默认没有集成<code>LESS</code>等样式预处理工具，可以通过修改目录下<code>/.storybook/main.js</code>文件来进行支持。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">webpackFinal: <span class="keyword">async</span> (config, &#123; configType &#125;) =&gt; &#123;</span><br><span class="line">  <span class="comment">// `configType`为'DEVELOPMENT'或者'PRODUCTION'</span></span><br><span class="line">  <span class="comment">// 其中'PRODUCTION'环境用于构建静态的storybook站点</span></span><br><span class="line">  <span class="comment">// 你可以基于环境的不同来设置不同的配置</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以对webpack config进行任何操作</span></span><br><span class="line">  config.module.rules.push(&#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>],</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="组件的设计原则"><a href="#组件的设计原则" class="headerlink" title="组件的设计原则"></a>组件的设计原则</h2><ul>
<li><strong>渐进增强</strong>：组件开发遵循<strong>“渐进增强”</strong>的策略，先保证基础功能的支持，避免一开始就过度设计。</li>
<li><strong>粒度把握</strong>：组件需要把握覆盖的功能规模，过大的粒度不利于复用，过小的粒度无法提现组件的优势。</li>
<li><strong>功能累加</strong>：组件的功能原则上只允许增加，不允许随意删减，避免影响现有业务的使用。</li>
<li><strong>无副作用</strong>：组件尽量为展示型组件，即只通过 props 接受数据和触发事件回调，不在组件内部做任何会产生副作用的动作，如：发业务请求、修改父组件数据等。<h2 id="组件文档规范"><a href="#组件文档规范" class="headerlink" title="组件文档规范"></a>组件文档规范</h2>由于我们新的工程中全面使用了<code>TypeScript</code>，这样更便于<code>Storybook</code>自动读取组件的参数进行展示。在此之外，还有一些组件平台维护规范需要遵守：</li>
<li>当前组件库包含以下几大一级标题（组件title示例：<code>title: &#39;Common/Button&#39;,</code>）：<ul>
<li>PC PC端独立UI组件</li>
<li>H5 H5端独立UI组件</li>
<li>Common 公共UI组件</li>
<li>Utils 非UI工具类组件</li>
<li>Others 其他组件</li>
</ul>
</li>
<li>每个<code>React</code>UI组件必须有对应的<code>*.stories.(js|jsx|ts|tsx)</code>文件，从而产生该组件的<code>story</code>文档。</li>
<li><p>每个组件在<code>Meta</code>中写明作者信息以便使用人咨询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  parameters: &#123;</span><br><span class="line">    docs: &#123;</span><br><span class="line">      description: &#123;</span><br><span class="line">        component: &apos;作者：hzliushichuan@corp.netease.com&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果组件的使用方式较为复杂，或者有任何非UI类的组件，可以使用<code>MDX</code>格式文件进行描述，非必要情况不推荐使用，容易造成组件文档的格式不统一。</p>
</li>
<li>组件的参数类型必须提供明确的<code>Typescript</code>定义，包括枚举值，函数返回值等，一般情况下不允许出现<code>Any</code>或者未定义的类型。</li>
<li>如果组件有多种重要的不同参数调用方式，必须在<code>stories</code>文件中通过多个<code>story</code>明确声明。</li>
</ul>
<h2 id="组件库的CI-CD自动化持续集成"><a href="#组件库的CI-CD自动化持续集成" class="headerlink" title="组件库的CI/CD自动化持续集成"></a>组件库的CI/CD自动化持续集成</h2><p>本次建立组件库的目的是让组内开发人员有统一的组件查询和共建平台，便于后续的长期扩展和维护工作，所以最好是具备已开发稳定的组件自动化的持续集成能力。</p>
<h3 id="使用Gitlab-CI-CD自动构建"><a href="#使用Gitlab-CI-CD自动构建" class="headerlink" title="使用Gitlab CI/CD自动构建"></a>使用<code>Gitlab CI/CD</code>自动构建</h3><p>配置文件比较简单，直接展示如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># image: node:alpine</span></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">build</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">storybook-static/</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build storybook</span></span><br><span class="line"><span class="attr">storybook:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">develop</span></span><br><span class="line"><span class="attr">  before_script:</span></span><br><span class="line">    <span class="comment"># 安装storybook的基础依赖</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">    <span class="comment"># 安装组件库的依赖</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">setup-components</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line">    <span class="comment"># 执行组件库静态化打包命令</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build-storybook</span></span><br></pre></td></tr></table></figure></p>
<h3 id="配合Gitlab-Runner的Docker实现持续集成"><a href="#配合Gitlab-Runner的Docker实现持续集成" class="headerlink" title="配合Gitlab Runner的Docker实现持续集成"></a>配合<code>Gitlab Runner</code>的<code>Docker</code>实现持续集成</h3><p><code>Gitlab Runner</code>是运行于<code>Docker</code>内的，它在执行完毕后会自动回收所有的资源。而我们需要将它自动化执行的<code>Storybook</code>构建的静态资源产物(<code>html/css/js</code>等），同步到持续集成的<code>Web Server</code>。所以需要配置<code>Gitlab Runner</code>的<code>Docker</code>共享宿主机的<code>volumes</code>，并且配置<code>Docker</code>内<code>Storybook</code>的构建目录指向这个宿主机提供的<code>volumes</code>，所以需要<code>Gitlab Runner</code>配置如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">concurrent</span> = <span class="number">4</span></span><br><span class="line"><span class="attr">check_interval</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[session_server]</span></span><br><span class="line">  session_timeout = 1800</span><br><span class="line"></span><br><span class="line"><span class="section">[[runners]]</span></span><br><span class="line">  name = "lofter frontend gitlab-runner"</span><br><span class="line">  url = "https://g.hz.netease.com/"</span><br><span class="line">  ...</span><br><span class="line"><span class="section">  [runners.docker]</span></span><br><span class="line">    tls_verify = false</span><br><span class="line">    image = "node:alpine"</span><br><span class="line">    ...</span><br><span class="line">    volumes = ["/cache", "/root/storybook-service/static:/storybook:rw"]</span><br><span class="line">    shm_size = 0</span><br></pre></td></tr></table></figure></p>
<p>其中<code>&quot;/root/storybook-service/static:/storybook:rw&quot;]</code>就是将宿主机的卷<code>/root/storybook-service/static</code>共享到<code>Docker</code>中的<code>/storybook</code>，并且修改<code>Storybook</code>的打包目录为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    scripts: &#123;</span><br><span class="line">      "build-storybook": "build-storybook --quiet -o /storybook"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样配置，就可以在宿主机拿到每次<code>Storybook</code>自动化构建后的产物然后再利用持续运行的Web Server展示出来。</p>
  
	</div>
		<footer class="article-footer clearfix">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/前端/">前端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Frontend/">Frontend</a><a href="/tags/Storybook/">Storybook</a><a href="/tags/Gitlab/">Gitlab</a><a href="/tags/CI-CD/">CI/CD</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://icewind-blog.com/2020/10/14/storybook/" data-title="如何使用Storybook和Gitlab CI/CD搭建自动化的前端公共组件库 | Icewind Blog" data-tsina="2099631680" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/2021/01/25/micro-frontends-in-lofter/" title="微前端在网易LOFTER中后台系统中的演进之路">
  <strong>上一篇：</strong><br>
  <span>
  微前端在网易LOFTER中后台系统中的演进之路</span>
</a>
</div>


<div class="next">
<a href="/2019/11/18/exprience-of-nodejs-development/" title="Node.js实践经验总结">
 <strong>下一篇：</strong><br> 
 <span>Node.js实践经验总结
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#选型"><span class="toc-number">1.</span> <span class="toc-text">选型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#需求"><span class="toc-number">1.1.</span> <span class="toc-text">需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对比"><span class="toc-number">1.2.</span> <span class="toc-text">对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bisheng"><span class="toc-number">1.2.1.</span> <span class="toc-text">Bisheng</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#优点"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缺点"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Storybook"><span class="toc-number">1.2.2.</span> <span class="toc-text">Storybook</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#优点-1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缺点-1"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Storybook-1"><span class="toc-number">2.</span> <span class="toc-text">Storybook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍"><span class="toc-number">2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用方式"><span class="toc-number">2.2.</span> <span class="toc-text">使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理简介"><span class="toc-number">2.3.</span> <span class="toc-text">原理简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用要点"><span class="toc-number">2.4.</span> <span class="toc-text">使用要点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件的设计原则"><span class="toc-number">3.</span> <span class="toc-text">组件的设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件文档规范"><span class="toc-number">4.</span> <span class="toc-text">组件文档规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件库的CI-CD自动化持续集成"><span class="toc-number">5.</span> <span class="toc-text">组件库的CI/CD自动化持续集成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Gitlab-CI-CD自动构建"><span class="toc-number">5.1.</span> <span class="toc-text">使用Gitlab CI/CD自动构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配合Gitlab-Runner的Docker实现持续集成"><span class="toc-number">5.2.</span> <span class="toc-text">配合Gitlab Runner的Docker实现持续集成</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Node/" title="Node">Node<sup>1</sup></a></li>
		
			<li><a href="/categories/Node-js/" title="Node.js">Node.js<sup>1</sup></a></li>
		
			<li><a href="/categories/前端/" title="前端">前端<sup>27</sup></a></li>
		
			<li><a href="/categories/博客/" title="博客">博客<sup>2</sup></a></li>
		
			<li><a href="/categories/数码/" title="数码">数码<sup>1</sup></a></li>
		
			<li><a href="/categories/随笔/" title="随笔">随笔<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/AJAX/" title="AJAX">AJAX<sup>1</sup></a></li>
		
			<li><a href="/tags/CI-CD/" title="CI/CD">CI/CD<sup>1</sup></a></li>
		
			<li><a href="/tags/CSS/" title="CSS">CSS<sup>9</sup></a></li>
		
			<li><a href="/tags/CSS3/" title="CSS3">CSS3<sup>1</sup></a></li>
		
			<li><a href="/tags/Egg-js/" title="Egg.js">Egg.js<sup>1</sup></a></li>
		
			<li><a href="/tags/Frontend/" title="Frontend">Frontend<sup>3</sup></a></li>
		
			<li><a href="/tags/Gitlab/" title="Gitlab">Gitlab<sup>1</sup></a></li>
		
			<li><a href="/tags/HTML/" title="HTML">HTML<sup>9</sup></a></li>
		
			<li><a href="/tags/HTML5/" title="HTML5">HTML5<sup>2</sup></a></li>
		
			<li><a href="/tags/IOS/" title="IOS">IOS<sup>1</sup></a></li>
		
			<li><a href="/tags/JSONP/" title="JSONP">JSONP<sup>1</sup></a></li>
		
			<li><a href="/tags/Javascript/" title="Javascript">Javascript<sup>12</sup></a></li>
		
			<li><a href="/tags/Javscript/" title="Javscript">Javscript<sup>2</sup></a></li>
		
			<li><a href="/tags/Lofter/" title="Lofter">Lofter<sup>1</sup></a></li>
		
			<li><a href="/tags/Micro-Frontends/" title="Micro Frontends">Micro Frontends<sup>1</sup></a></li>
		
			<li><a href="/tags/Node/" title="Node">Node<sup>2</sup></a></li>
		
			<li><a href="/tags/Node-js/" title="Node.js">Node.js<sup>1</sup></a></li>
		
			<li><a href="/tags/Puppeteer/" title="Puppeteer">Puppeteer<sup>1</sup></a></li>
		
			<li><a href="/tags/Rich-text-editor/" title="Rich text editor">Rich text editor<sup>1</sup></a></li>
		
			<li><a href="/tags/Sentry/" title="Sentry">Sentry<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><a href="http://bbs.byr.cn/" target="_blank" title="BYR">北邮人论坛</a></li>
      <li><a href="http://yangjian.me" target="_blank" title="YangJian">Alimon's Blog</a></li>
      <li><a href="http://zipperary.com/" target="_blank" title="zippera">Zippera's Blog</a></li>
      <li><a href="http://wuchong.me/" target="_blank" title="WuChong">Jark's Blog</a></li>
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer">
	
	<div class="line">
		<span></span>
		
		<a href="http://weibo.com/2099631680" target="_blank"><div class="author"></div></a>
		
	</div>
	
	
	<section class="info">
		<p> Hello,I&#39;m Icewind. For now I&#39;m a developer of FE in Hangzhou. <br>
			I&#39;ll share my learning experience with you at this blog.</p>
	</section>
	 
	<div class="social-font">
		
		<a href="http://weibo.com/2099631680" target="_blank" class="icon-weibo" title="weibo"></a>
		
		
		<a href="https://github.com/icewind7030" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="mailto:liushichuan@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Pacman">Jacman</a> © 2021 
		
		<a href="http://icewind-blog.com/about" target="_blank" title="Icewind">Icewind</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox({
      type: 'image'
    });
  }
}); 
</script>


<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-51186401-1', 'icewind-blog.com');  
ga('send', 'pageview');
</script>


<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"></a>
</div>

<script src="/js/totop.js"></script>

<script type="text/x-mathjax-config"> 
MathJax.Hub.Config({ 
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} 
}); 
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  </body>
</html>
